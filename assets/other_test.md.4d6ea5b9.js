import{_ as s,o as a,c as e,U as t}from"./chunks/framework.97dce334.js";const y=JSON.parse('{"title":"test","description":"","frontmatter":{},"headers":[],"relativePath":"other/test.md","filePath":"other/test.md","lastUpdated":1689847786000}'),l={name:"other/test.md"},n=t(`<h1 id="test" tabindex="-1">test <a class="header-anchor" href="#test" aria-label="Permalink to &quot;test&quot;">​</a></h1><p><a href="https://testing.cuixueshe.com/" target="_blank" rel="noreferrer">_</a></p><ul><li>保持单元测试的可读性(测试非常重视可读性和可维护性, 只有测试的维护成本小于业务代码的维护成本, 才会愿意去维护它)</li></ul><h2 id="vitest" tabindex="-1">vitest <a class="header-anchor" href="#vitest" aria-label="Permalink to &quot;vitest&quot;">​</a></h2><blockquote><p>开箱即用、共用 vite 配置(意味着可以开发环境, 构建环境, 测试环境共用同一套配置)</p></blockquote><p>use</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 安装</span></span>
<span class="line"><span style="color:#FFCB6B;">pnpm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">i</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">vitest</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-D</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 测试</span></span>
<span class="line"><span style="color:#FFCB6B;">vitest</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span></span></code></pre></div><h2 id="jest" tabindex="-1">jest <a class="header-anchor" href="#jest" aria-label="Permalink to &quot;jest&quot;">​</a></h2><blockquote><p>构建和开发是分开的配置, 有一定的维护成本</p></blockquote><p>use</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 安装</span></span>
<span class="line"><span style="color:#FFCB6B;">pnpm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">i</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">jest</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">typescript</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">@types/jest</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ts-jest</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-D</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 初始化配置</span></span>
<span class="line"><span style="color:#FFCB6B;">npx</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ts-jest</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">config:init</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 测试</span></span>
<span class="line"><span style="color:#FFCB6B;">jest</span></span></code></pre></div><h2 id="创建测试数据的三种方式" tabindex="-1">创建测试数据的三种方式 <a class="header-anchor" href="#创建测试数据的三种方式" aria-label="Permalink to &quot;创建测试数据的三种方式&quot;">​</a></h2><ol><li><p>内联 in-line</p><blockquote><p>直接在 test/it 中创建数据</p></blockquote><p>测试数据比较简单的时候可以直接使用内联的方式</p></li><li><p>委托 Delegated</p><blockquote><p>工厂函数, 可复用的话可以抽离成文件</p></blockquote><p>测试数据比较复杂的时候可以使用委托</p></li><li><p>隐式 Implicit</p><blockquote><p>beforeEach 里面创建</p></blockquote><p>测试数据一样的时候, 可以使用隐式的方式</p></li></ol><h2 id="最小准备测试数据原则" tabindex="-1">最小准备测试数据原则 <a class="header-anchor" href="#最小准备测试数据原则" aria-label="Permalink to &quot;最小准备测试数据原则&quot;">​</a></h2><blockquote><p>当前测试 case 中没有用的数据就不要创建, 保持单元测试的可读性</p></blockquote><ol><li><p>默认参数的方式</p><blockquote><p>这种方式会改变原本的业务代码, 但是这并不影响. 单元测试也是业务逻辑的用户之一, 单元测试可以驱动我们设计出更好用的 api 比如测试一个 class 需要 new class 并传入一系列的属性, 如果当前测试只要 name 那就不要创建 name 以外的属性, 可以用默认参数为 &quot;&quot; 来让 new class 时只传入 name 属性</p></blockquote></li><li><p>委托工厂函数来隐藏不需要的属性</p><p>编写一个 <code>createUser</code> 函数, 这个函数只接受一个 name 属性, 并返回 <code>new class(name, ...default)</code>, 通过这个函数设置默认值, 写测试 case 的时候就只需要调用 <code>createUser(name)</code> 来隐藏其他属性, 保持可读性</p></li><li><p>虚拟对象的方式</p><p><code>const user = { name: &#39;userName&#39; } as User</code> 通过类型断言来解决类型问题, 来保持创建最小准备测试数据的原则</p></li></ol>`,16),o=[n];function p(c,r,i,d,h,u){return a(),e("div",null,o)}const b=s(l,[["render",p]]);export{y as __pageData,b as default};
