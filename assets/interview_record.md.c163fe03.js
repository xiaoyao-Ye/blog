import{_ as s,o as l,c as a,U as p}from"./chunks/framework.97dce334.js";const C=JSON.parse('{"title":"记录一些面试题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/record.md","filePath":"interview/record.md","lastUpdated":1700208924000}'),n={name:"interview/record.md"},o=p(`<h1 id="记录一些面试题" tabindex="-1">记录一些面试题 <a class="header-anchor" href="#记录一些面试题" aria-label="Permalink to &quot;记录一些面试题&quot;">​</a></h1><h2 id="已整理" tabindex="-1">已整理 <a class="header-anchor" href="#已整理" aria-label="Permalink to &quot;已整理&quot;">​</a></h2><ol><li><p>position 的值， relative 和 absolute 分别是相对于谁进行定位的？</p><ul><li>absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。</li><li>fixed （老 IE 不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。</li><li>relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li><li>static 默认值。没有定位，元素出现在正常的流中</li></ul></li><li><p>XML 和 JSON 的区别？</p><ul><li>数据体积方面: JSON 相对于 XML 来讲，数据的体积小，传递的速度更快些。</li><li>数据交互方面: JSON 与 JavaScript 的交互更加方便，更容易解析处理，更好的数据交互。</li><li>数据描述方面: JSON 对数据的描述性比 XML 较差。</li><li>传输速度方面: JSON 的速度要远远快于 XML。</li></ul></li><li><p>清除浮动的几种方式，各自的优缺点</p><ul><li>使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）</li><li>使用 overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用 zoom:1 用于兼容 IE）</li><li>是用 after 伪元素清除浮动(用于非 IE 浏览器)</li></ul></li><li><p>浏览器的垃圾回收机制（方法说出来，然后听听候选人自己能讲多少即可）</p><p>垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关，而浏览器实现标识无用变量的策略主要有下两个方法：</p><ol><li><p>引用计数法跟踪记录每个值被引用的次数</p><p>当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是 1.</p><p>如果同一个值又被赋给另一个变量，则该值的引用次数加 1.</p><p>相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减 1.</p><p>当这个值的引用次数变成 0 时，则说明没有办法访问这个值了，因此就 可以将其占用的内存空间回收回来。 如：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{};</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//对象{}的引用计数为 1</span></span>
<span class="line"><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> a</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">      </span><span style="color:#676E95;font-style:italic;">//对象{}的引用计数为 1+1</span></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span><span style="color:#A6ACCD;">   </span><span style="color:#676E95;font-style:italic;">//对象{}的引用计数为 2-1</span></span></code></pre></div><p>所以这时对象{}不会被回收;</p><p>IE 6, 7 对 DOM 对象进行引用计数回收，这样简单的垃圾回收机制，非常容易出现循环引用问题导致内存不能被回收，进行导致内存泄露等问题，一般不用引用计数法。</p></li><li><p>标记清除法</p><p>到 2008 年为止，IE,Firefox,Opera,Chrome 和 Safari 的 javascript 实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。</p><p>标记清除的算法分为两个阶段，标记(mark)和清除(sweep). 第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。</p></li></ol></li><li><p>哪些常见操作会造成内存泄漏？</p><blockquote><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。概念）</p></blockquote><p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p><ul><li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li><li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。</li></ul></li><li><p>前端优化（提高网页的加载速度） ？</p><ol><li>减少 http 请求数</li><li>使用缓存</li><li>压缩 js，css 文件，减小文件体积</li><li>使用 cdn，减小服务器负担</li><li>懒加载图片</li><li>预加载 css，js 文件</li><li>避免 dom 结构的深层次嵌套</li><li>给 DOM 元素添加样式时，把样式放到类中，直接给元素添加类，减少重构，回流</li></ol></li><li><p>this 对象的理解？</p><ul><li>this 总是指向函数的直接调用者（而非间接调用者）；</li><li>如果有 new 关键字，this 指向 new 出来的那个对象；</li><li>在事件中，this 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 this 总是指向全局对象 Window。</li></ul></li><li><p>Javascript 如何实现继承？</p><blockquote><p>听到这几个关键词就行，后面让候选人自己展开讲，越多一般能说明基础越扎实，理解越深</p></blockquote><ol><li>构造继承</li><li>原型继承</li><li>实例继承</li><li>拷贝继承</li></ol></li><li><p>如何放 sql 注入</p><blockquote><p>防 sql 注入基本所有页面都会做，就算没做过，概念也会听过</p></blockquote><p>sql 注入原理:</p><p>就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。</p><p>总的来说有以下几点：</p><ol><li>永远不要信任用户的输入，要对用户的输入进行校验，<code>可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等</code>。</li><li>永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。</li><li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li><code>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息</code>。</li></ol></li><li><p>选择器有哪些?</p><ul><li>id 选择器.</li><li>类选择器.</li><li>标签选择器.</li><li>伪类选择器.</li><li>伪元素选择器.</li><li>通配符</li><li>属性选择器.</li><li>组合选择器.</li></ul></li><li><p>js 判断数组的方法?</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> arr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 1.instanceof 操作符判断===instanceof 主要是用来判断某个实例是否属于某个对象</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// arr instanceof Array;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(arr </span><span style="color:#89DDFF;">instanceof</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Array</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">          </span><span style="color:#676E95;font-style:italic;">//true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 2.对象构造函数的 constructor判断===Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// arr.constructor === Array;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(arr</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> Array)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">     </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 3.Array 原型链上的 isPrototypeOf===Array.prototype  属性表示 Array 构造函数的原型===其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。</span></span>
<span class="line"><span style="color:#FFCB6B;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isPrototypeOf</span><span style="color:#A6ACCD;">(arr)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isPrototypeOf</span><span style="color:#A6ACCD;">(arr))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 4.Object.getPrototypeOf===Object.getPrototypeOf() 方法返回指定对象的原型</span></span>
<span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPrototypeOf</span><span style="color:#A6ACCD;">(arr) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPrototypeOf</span><span style="color:#A6ACCD;">(arr) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 5.Object.prototype.toString===虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。</span></span>
<span class="line"><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">toString</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#A6ACCD;">(arr) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">[object Array]</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">toString</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#A6ACCD;">(arr) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">[object Array]</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 6.Array.isArray===用法：Array.isArray(arr) ,ES5中新增了Array.isArray方法,IE8及以下不支持</span></span>
<span class="line"><span style="color:#A6ACCD;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isArray</span><span style="color:#A6ACCD;">(arr)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isArray</span><span style="color:#A6ACCD;">(arr))</span><span style="color:#89DDFF;">;</span></span></code></pre></div></li><li><p>用 JS 实现把两个数组合并，并删除元素</p><p>合并 js 数组用 concat 方法，array1.concat(array2)。 删除元素用 splice 方法，splice(1,1)，函数原型 splice(index,count)，指从数组索引 1 处开始删除 1 个元素，索引从 0 开始，即删除第二个元素。</p></li><li><p>CSS 之左右固定，中间自适应</p><p>① 运用 float,左右浮动,中间采用 margin-left 和 margin-right (三个 div 的顺序：center 必须是最后一个) ② 左右两侧采用绝对定位 中间同样采用 margin-left margin-right 方法 (不需要考虑 div 的顺序) ③flex 左右设定固定宽度 中间设置 flex:1 (按顺序写)</p></li><li><p>怎么看 Vue3.0(对 vue3.0 的了解)</p><p>Vue3.0 和 Vue2.0 的区别? vue3.0 主要优化的几点大概是:</p><ul><li>实现了数组的全方面监听，数据的监听方式由 getter/setter 改为了 proxy 代理，以及可以对目标对象选择监听</li><li>默认进行懒观察（lazy observation）。在 2.0 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对 <code>被用于渲染初始可见部分的数据</code> 创建观察者，而且 3.x 的观察者更高效。</li><li>更精准的变更通知。 比例来说：2.x 版本中，你使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。</li><li>版本 3.0 新加入了 TypeScript 以及 PWA 的支持: 布局的新技术,在网页应用中实现和原生应用相近的用户体验的渐进式网页应用</li><li>新增 .browserslistrc 文件部分命令发生了变化,做浏览器的兼容</li><li>命令改变</li></ul><p>下载安装 npm install -g vue@cli 删除了 vue list</p><p>创建项目 vue create</p><p>启动项目 npm run serve</p><p>默认项目目录结构也发生了变化： 移除了配置文件目录，config 和 build 文件夹 移除了 static 文件夹，</p><p>新增 public 文件夹，并且 index.html 移动到 public 中 在 src 文件夹中新增了 views 文件夹，用于分类 视图组件 和 公共组件</p></li><li><p>异步请求要得到结果后才能进行下一步操作该怎么做?</p></li><li><p>当后端一次返回过多数据, 前端应该如何优化处理?</p><blockquote><p>首先, 一般情况下不会出现这种情况, 单个接口返回大量数据这种情况对服务器来说也是需要进行优化的(缓存?)</p></blockquote><ol><li>后端接口分页</li><li>前端得到大量数据不意味着一定要一次渲染上去, 可以通过 setTimeout 进行分页渲染, 一次渲染一页(这里是前端分页),分页后数据可以快速渲染到屏幕上, 减少页面的空白时间, 直到渲染完所有.</li><li>可以使用 requestAnimationFrame 代替 setTimeout, 浏览器自己控制渲染时机</li><li>渲染分页的时候不必每个循环都 appendChild 元素到页面, 可以把需要渲染的元素合并成一个文档片段, 一个分页只 appendChild 一次</li><li>延迟加载 在列表末尾加一个空白节点, 用来判断是否进入可视区, 一但空白节点进入可视区意味着需要继续渲染数据了, 同时可以使用 getBoundingClientRect 来判断空白是否在页面底部.</li></ol></li></ol><h2 id="待整理" tabindex="-1">待整理 <a class="header-anchor" href="#待整理" aria-label="Permalink to &quot;待整理&quot;">​</a></h2><blockquote><p>所有答案最好结合使用场景</p></blockquote><ul><li>对于 Vue3 的了解</li><li>什么是防抖节流</li><li>路由有哪些模式</li><li>Http https 的区别</li><li>v-if v-show 的区别</li><li>css 和 Css3 的区别</li><li>虚拟 Dom 和 diff 算法</li><li>cookie local-storage 与 session storage 的区别</li><li>Vue 项目实践 性能优化</li><li>怎么封装一个组件</li><li>Css 选择器</li><li>组件通信方式有哪些</li><li>说一下跨域, (同源策略)怎么解决</li><li>Uniapp</li><li>定位不准，ip gps ,不同 sdk 坐标转换</li><li>闭包</li></ul>`,6),t=[o];function e(r,i,c,y,A,D){return l(),a("div",null,t)}const u=s(n,[["render",e]]);export{C as __pageData,u as default};
